/*
 * Copyright (c) ContextEngine Team 2024. All rights reserved.
 */
package contextengine.tests

import std.collection.HashMap
import std.collection.ArrayList
import contextengine.models.MemoryRecord
import contextengine.core.memory.{SemanticSimilarityDetector, SemanticSimilarityConfig, MemoryMerger, MemoryMergerConfig, MemoryDeduplicator, DeduplicationConfig, ConflictResolver, ConflictResolverConfig}

/**
 * Phase 1.4 åŠŸèƒ½éªŒè¯
 * éªŒè¯è®°å¿†åˆå¹¶å’Œå»é‡çš„æ ¸å¿ƒåŠŸèƒ½
 */
public class Phase14Validation {
    
    /**
     * è¿è¡ŒPhase 1.4åŠŸèƒ½éªŒè¯
     */
    public func runValidation(): Bool {
        println("=== Phase 1.4 è®°å¿†åˆå¹¶å’Œå»é‡åŠŸèƒ½éªŒè¯ ===")
        
        var allTestsPassed = true
        
        // æµ‹è¯•1: è¯­ä¹‰ç›¸ä¼¼æ€§æ£€æµ‹
        if (!testSemanticSimilarity()) {
            allTestsPassed = false
        }
        
        // æµ‹è¯•2: è®°å¿†åˆå¹¶
        if (!testMemoryMerging()) {
            allTestsPassed = false
        }
        
        // æµ‹è¯•3: è‡ªåŠ¨å»é‡
        if (!testMemoryDeduplication()) {
            allTestsPassed = false
        }
        
        // æµ‹è¯•4: å†²çªæ£€æµ‹
        if (!testConflictDetection()) {
            allTestsPassed = false
        }
        
        if (allTestsPassed) {
            println("ğŸ‰ Phase 1.4 æ‰€æœ‰åŠŸèƒ½éªŒè¯é€šè¿‡ï¼")
        } else {
            println("âŒ Phase 1.4 éƒ¨åˆ†åŠŸèƒ½éªŒè¯å¤±è´¥")
        }
        
        return allTestsPassed
    }
    
    /**
     * æµ‹è¯•è¯­ä¹‰ç›¸ä¼¼æ€§æ£€æµ‹
     */
    private func testSemanticSimilarity(): Bool {
        println("\n--- æµ‹è¯•è¯­ä¹‰ç›¸ä¼¼æ€§æ£€æµ‹ ---")
        
        try {
            let detector = SemanticSimilarityDetector()
            
            // åˆ›å»ºæµ‹è¯•è®°å¿†
            let memory1 = createTestMemory("test1", "æˆ‘å–œæ¬¢å–å’–å•¡")
            let memory2 = createTestMemory("test2", "æˆ‘å¾ˆå–œæ¬¢å–å’–å•¡")
            let memory3 = createTestMemory("test3", "æˆ‘ä¸å–œæ¬¢å–èŒ¶")
            
            // æµ‹è¯•ç›¸ä¼¼è®°å¿†æ£€æµ‹
            let similarity1 = detector.detectSimilarity(memory1, memory2)
            println("ç›¸ä¼¼è®°å¿†æ£€æµ‹: ${similarity1.similarity} (é˜ˆå€¼: 0.8)")
            
            // æµ‹è¯•ä¸ç›¸ä¼¼è®°å¿†æ£€æµ‹
            let similarity2 = detector.detectSimilarity(memory1, memory3)
            println("ä¸ç›¸ä¼¼è®°å¿†æ£€æµ‹: ${similarity2.similarity}")
            
            // æµ‹è¯•æ–‡æœ¬ç›¸ä¼¼æ€§
            let textSimilarity = detector.detectTextSimilarity("æˆ‘å–œæ¬¢å’–å•¡", "æˆ‘å¾ˆå–œæ¬¢å’–å•¡")
            println("æ–‡æœ¬ç›¸ä¼¼æ€§: ${textSimilarity.similarity}")
            
            // æµ‹è¯•é‡å¤è®°å¿†ç»„æ£€æµ‹
            let memories = [memory1, memory2, memory3]
            let duplicateGroups = detector.detectDuplicateGroups(memories)
            println("é‡å¤è®°å¿†ç»„æ•°é‡: ${duplicateGroups.size}")
            
            // éªŒè¯ç»“æœ
            let passed = duplicateGroups.size >= 0  // åŸºæœ¬éªŒè¯
            println("è¯­ä¹‰ç›¸ä¼¼æ€§æ£€æµ‹: ${if (passed) { "âœ… é€šè¿‡" } else { "âŒ å¤±è´¥" }}")
            return passed
            
        } catch (e: Exception) {
            println("è¯­ä¹‰ç›¸ä¼¼æ€§æ£€æµ‹æµ‹è¯•å¤±è´¥: ${e}")
            return false
        }
    }
    
    /**
     * æµ‹è¯•è®°å¿†åˆå¹¶
     */
    private func testMemoryMerging(): Bool {
        println("\n--- æµ‹è¯•è®°å¿†åˆå¹¶ ---")
        
        try {
            let merger = MemoryMerger()
            
            // åˆ›å»ºç›¸ä¼¼è®°å¿†ç»„
            let memory1 = createTestMemory("merge1", "æˆ‘å–œæ¬¢å–å’–å•¡")
            let memory2 = createTestMemory("merge2", "æˆ‘å¾ˆå–œæ¬¢å–å’–å•¡ï¼Œç‰¹åˆ«æ˜¯æ‹¿é“")
            let memory3 = createTestMemory("merge3", "å’–å•¡æ˜¯æˆ‘æœ€å–œæ¬¢çš„é¥®æ–™")
            
            let memoryGroup = [memory1, memory2, memory3]
            
            // æµ‹è¯•æ™ºèƒ½åˆå¹¶
            let mergeResult = merger.mergeMemoryGroup(memoryGroup, None)
            let mergeSuccess = mergeResult.isSome()
            println("æ™ºèƒ½åˆå¹¶: ${if (mergeSuccess) { "æˆåŠŸ" } else { "å¤±è´¥" }}")
            
            if (mergeSuccess) {
                let result = mergeResult.getOrThrow()
                println("åˆå¹¶ç­–ç•¥: ${result.strategy.toString()}")
                println("åˆå¹¶ç½®ä¿¡åº¦: ${result.confidence}")
                println("åŸå§‹è®°å¿†æ•°é‡: ${result.originalMemories.size}")
            }
            
            // æµ‹è¯•å†…å®¹èåˆ
            let fusedContent = merger.fuseContent(memoryGroup)
            println("å†…å®¹èåˆé•¿åº¦: ${fusedContent.size}")
            
            // æµ‹è¯•åˆå¹¶ç»Ÿè®¡
            let stats = merger.getMergeStatistics()
            println("åˆå¹¶ç»Ÿè®¡é¡¹æ•°: ${stats.size}")
            
            println("è®°å¿†åˆå¹¶: âœ… é€šè¿‡")
            return true
            
        } catch (e: Exception) {
            println("è®°å¿†åˆå¹¶æµ‹è¯•å¤±è´¥: ${e}")
            return false
        }
    }
    
    /**
     * æµ‹è¯•è‡ªåŠ¨å»é‡
     */
    private func testMemoryDeduplication(): Bool {
        println("\n--- æµ‹è¯•è‡ªåŠ¨å»é‡ ---")
        
        try {
            let deduplicator = MemoryDeduplicator()
            
            // åˆ›å»ºåŒ…å«é‡å¤çš„è®°å¿†åˆ—è¡¨
            let memories = ArrayList<MemoryRecord>()
            memories.add(createTestMemory("dup1", "æˆ‘å–œæ¬¢å–å’–å•¡"))
            memories.add(createTestMemory("dup2", "æˆ‘å¾ˆå–œæ¬¢å–å’–å•¡"))
            memories.add(createTestMemory("dup3", "æˆ‘å–œæ¬¢å–èŒ¶"))
            memories.add(createTestMemory("dup4", "ä»Šå¤©å¤©æ°”å¾ˆå¥½"))
            
            let memoryArray = memories.toArray()
            
            // æµ‹è¯•å»é‡å¤„ç†
            let (dedupResult, processedMemories) = deduplicator.deduplicateMemories(memoryArray)
            
            println("åŸå§‹æ•°é‡: ${dedupResult.originalCount}")
            println("æœ€ç»ˆæ•°é‡: ${processedMemories.size}")
            println("å»é‡ç‡: ${dedupResult.deduplicationRate}%")
            println("å¤„ç†æ—¶é—´: ${dedupResult.processingTime}ms")
            
            // æµ‹è¯•å¿«é€Ÿé‡å¤æ£€æŸ¥
            let hasDuplicates = deduplicator.haseDuplicates(memoryArray)
            println("å­˜åœ¨é‡å¤: ${hasDuplicates}")
            
            // æµ‹è¯•å»é‡ç»Ÿè®¡
            let stats = deduplicator.getDeduplicationStatistics()
            println("ç»Ÿè®¡é¡¹æ•°: ${stats.size}")
            
            // éªŒè¯å»é‡æ•ˆæœ
            let passed = processedMemories.size <= memoryArray.size
            println("è‡ªåŠ¨å»é‡: ${if (passed) { "âœ… é€šè¿‡" } else { "âŒ å¤±è´¥" }}")
            return passed
            
        } catch (e: Exception) {
            println("è‡ªåŠ¨å»é‡æµ‹è¯•å¤±è´¥: ${e}")
            return false
        }
    }
    
    /**
     * æµ‹è¯•å†²çªæ£€æµ‹
     */
    private func testConflictDetection(): Bool {
        println("\n--- æµ‹è¯•å†²çªæ£€æµ‹ ---")
        
        try {
            let resolver = ConflictResolver()
            
            // åˆ›å»ºå¯èƒ½å†²çªçš„è®°å¿†
            let memory1 = createTestMemory("conflict1", "æˆ‘å–œæ¬¢å–å’–å•¡")
            let memory2 = createTestMemory("conflict2", "æˆ‘ä¸å–œæ¬¢å–å’–å•¡")
            let memory3 = createTestMemory("conflict3", "æˆ‘ä½åœ¨åŒ—äº¬")
            let memory4 = createTestMemory("conflict4", "æˆ‘ä½åœ¨ä¸Šæµ·")
            
            let memories = [memory1, memory2, memory3, memory4]
            
            // æµ‹è¯•å†²çªæ£€æµ‹
            let conflicts = resolver.detectConflicts(memories)
            println("æ£€æµ‹åˆ°å†²çªæ•°é‡: ${conflicts.size}")
            
            // æµ‹è¯•å†²çªè§£å†³
            var resolvedCount: Int64 = 0
            for (conflict in conflicts) {
                let resolution = resolver.resolveConflict(conflict, None)
                if (resolution.isSome()) {
                    resolvedCount = resolvedCount + 1
                }
            }
            println("æˆåŠŸè§£å†³å†²çªæ•°é‡: ${resolvedCount}")
            
            // æµ‹è¯•å†²çªç»Ÿè®¡
            let stats = resolver.getConflictStatistics()
            println("å†²çªç»Ÿè®¡é¡¹æ•°: ${stats.size}")
            
            // æµ‹è¯•å¾…å®¡æ ¸å†²çª
            let pendingReviews = resolver.getPendingManualReviews()
            println("å¾…å®¡æ ¸å†²çªæ•°é‡: ${pendingReviews.size}")
            
            println("å†²çªæ£€æµ‹: âœ… é€šè¿‡")
            return true
            
        } catch (e: Exception) {
            println("å†²çªæ£€æµ‹æµ‹è¯•å¤±è´¥: ${e}")
            return false
        }
    }
    
    /**
     * åˆ›å»ºæµ‹è¯•è®°å¿†
     */
    private func createTestMemory(id: String, content: String): MemoryRecord {
        let metadata = HashMap<String, String>()
        metadata["source"] = "test"
        metadata["type"] = "validation"
        
        return MemoryRecord(id, content, "hash_${id}", 0.5, 0, None, metadata)
    }
}
