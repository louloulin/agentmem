/*
 * Copyright (c) ContextEngine Team 2024. All rights reserved.
 */
package contextengine.tests

import std.collection.HashMap
import std.collection.ArrayList
import std.time.DateTime
import contextengine.models.MemoryRecord
import contextengine.core.memory.{SemanticSimilarityDetector, SemanticSimilarityConfig, MemoryMerger, MemoryMergerConfig, MemoryDeduplicator, DeduplicationConfig, ConflictResolver, ConflictResolverConfig, MergeStrategy, DeduplicationPriority}

/**
 * Phase 1.4 è®°å¿†åˆå¹¶å’Œå»é‡æµ‹è¯•
 * æµ‹è¯•è¯­ä¹‰ç›¸ä¼¼æ€§æ£€æµ‹ã€è®°å¿†åˆå¹¶ã€è‡ªåŠ¨å»é‡å’Œå†²çªå¤„ç†åŠŸèƒ½
 */
public class Phase14Test {
    private var testResults: HashMap<String, Bool>
    private var testCount: Int64
    private var passedCount: Int64
    
    public init() {
        this.testResults = HashMap<String, Bool>()
        this.testCount = 0
        this.passedCount = 0
    }
    
    /**
     * è¿è¡Œæ‰€æœ‰Phase 1.4æµ‹è¯•
     */
    public func runAllTests(): Bool {
        println("=== Phase 1.4 è®°å¿†åˆå¹¶å’Œå»é‡æµ‹è¯•å¼€å§‹ ===")
        
        // æµ‹è¯•è¯­ä¹‰ç›¸ä¼¼æ€§æ£€æµ‹
        testSemanticSimilarityDetection()
        
        // æµ‹è¯•è®°å¿†åˆå¹¶ç­–ç•¥
        testMemoryMerging()
        
        // æµ‹è¯•è‡ªåŠ¨å»é‡æœºåˆ¶
        testMemoryDeduplication()
        
        // æµ‹è¯•å†²çªå¤„ç†
        testConflictResolution()
        
        // æµ‹è¯•é›†æˆåŠŸèƒ½
        testIntegratedDeduplicationWorkflow()
        
        // æµ‹è¯•æ€§èƒ½æŒ‡æ ‡
        testPerformanceMetrics()
        
        // è¾“å‡ºæµ‹è¯•ç»“æœ
        printTestResults()
        
        return passedCount == testCount
    }
    
    /**
     * æµ‹è¯•è¯­ä¹‰ç›¸ä¼¼æ€§æ£€æµ‹åŠŸèƒ½
     */
    private func testSemanticSimilarityDetection(): Unit {
        println("\n--- æµ‹è¯•è¯­ä¹‰ç›¸ä¼¼æ€§æ£€æµ‹åŠŸèƒ½ ---")
        
        // åˆ›å»ºç›¸ä¼¼æ€§æ£€æµ‹å™¨
        let config = SemanticSimilarityConfig(0.8, 0.3, 0.75)
        let detector = SemanticSimilarityDetector(config)
        
        // åˆ›å»ºæµ‹è¯•è®°å¿†
        let memory1 = createTestMemory("memory_1", "æˆ‘å–œæ¬¢å–å’–å•¡", "user1")
        let memory2 = createTestMemory("memory_2", "æˆ‘å¾ˆå–œæ¬¢å–å’–å•¡", "user1")
        let memory3 = createTestMemory("memory_3", "æˆ‘ä¸å–œæ¬¢å–èŒ¶", "user1")
        let memory4 = createTestMemory("memory_4", "ä»Šå¤©å¤©æ°”å¾ˆå¥½", "user1")
        
        // æµ‹è¯•ç›¸ä¼¼è®°å¿†æ£€æµ‹
        let similarity1 = detector.detectSimilarity(memory1, memory2)
        recordTest("ç›¸ä¼¼è®°å¿†æ£€æµ‹", similarity1.isSimilar && similarity1.similarity > 0.7)
        
        // æµ‹è¯•ä¸ç›¸ä¼¼è®°å¿†æ£€æµ‹
        let similarity2 = detector.detectSimilarity(memory1, memory4)
        recordTest("ä¸ç›¸ä¼¼è®°å¿†æ£€æµ‹", !similarity2.isSimilar)
        
        // æµ‹è¯•æ–‡æœ¬ç›¸ä¼¼æ€§
        let textSimilarity = detector.detectTextSimilarity("æˆ‘å–œæ¬¢å’–å•¡", "æˆ‘å¾ˆå–œæ¬¢å’–å•¡")
        recordTest("æ–‡æœ¬ç›¸ä¼¼æ€§æ£€æµ‹", textSimilarity.similarity > 0.6)
        
        // æµ‹è¯•æ‰¹é‡ç›¸ä¼¼è®°å¿†æŸ¥æ‰¾
        let candidateMemories = [memory2, memory3, memory4]
        let similarMemories = detector.findSimilarMemories(memory1, candidateMemories)
        recordTest("æ‰¹é‡ç›¸ä¼¼è®°å¿†æŸ¥æ‰¾", similarMemories.size > 0)
        
        // æµ‹è¯•é‡å¤è®°å¿†ç»„æ£€æµ‹
        let allMemories = [memory1, memory2, memory3, memory4]
        let duplicateGroups = detector.detectDuplicateGroups(allMemories)
        recordTest("é‡å¤è®°å¿†ç»„æ£€æµ‹", duplicateGroups.size > 0)
        
        // æµ‹è¯•ç»Ÿè®¡ä¿¡æ¯
        let stats = detector.getSimilarityStatistics(allMemories)
        recordTest("ç›¸ä¼¼æ€§ç»Ÿè®¡ä¿¡æ¯", stats.size > 0 && stats.contains("total_memories"))
        
        println("è¯­ä¹‰ç›¸ä¼¼æ€§æ£€æµ‹æµ‹è¯•å®Œæˆ")
    }
    
    /**
     * æµ‹è¯•è®°å¿†åˆå¹¶ç­–ç•¥
     */
    private func testMemoryMerging(): Unit {
        println("\n--- æµ‹è¯•è®°å¿†åˆå¹¶ç­–ç•¥ ---")
        
        // åˆ›å»ºè®°å¿†åˆå¹¶å™¨
        let config = MemoryMergerConfig(MergeStrategy.INTELLIGENT_MERGE, 0.8, 5)
        let detector = SemanticSimilarityDetector()
        let merger = MemoryMerger(config, detector)
        
        // åˆ›å»ºç›¸ä¼¼è®°å¿†ç»„
        let memory1 = createTestMemory("merge_1", "æˆ‘å–œæ¬¢å–å’–å•¡", "user1")
        memory1.importance = 0.8
        
        let memory2 = createTestMemory("merge_2", "æˆ‘å¾ˆå–œæ¬¢å–å’–å•¡ï¼Œç‰¹åˆ«æ˜¯æ‹¿é“", "user1")
        memory2.importance = 0.9
        
        let memory3 = createTestMemory("merge_3", "å’–å•¡æ˜¯æˆ‘æœ€å–œæ¬¢çš„é¥®æ–™", "user1")
        memory3.importance = 0.7
        
        let memoryGroup = [memory1, memory2, memory3]
        
        // æµ‹è¯•æ™ºèƒ½åˆå¹¶ç­–ç•¥
        let mergeResult = merger.mergeMemoryGroup(memoryGroup, Some(MergeStrategy.INTELLIGENT_MERGE))
        recordTest("æ™ºèƒ½åˆå¹¶ç­–ç•¥", mergeResult.isSome())
        
        if (mergeResult.isSome()) {
            let result = mergeResult.getOrThrow()
            recordTest("åˆå¹¶ç»“æœåŒ…å«åŸå§‹è®°å¿†", result.originalMemories.size == 3)
            recordTest("åˆå¹¶ç½®ä¿¡åº¦åˆç†", result.confidence > 0.5)
        }
        
        // æµ‹è¯•ä¿ç•™æœ€æ–°ç­–ç•¥
        let latestResult = merger.mergeMemoryGroup(memoryGroup, Some(MergeStrategy.KEEP_LATEST))
        recordTest("ä¿ç•™æœ€æ–°ç­–ç•¥", latestResult.isSome())
        
        // æµ‹è¯•ä¿ç•™æœ€é‡è¦ç­–ç•¥
        let importantResult = merger.mergeMemoryGroup(memoryGroup, Some(MergeStrategy.KEEP_MOST_IMPORTANT))
        recordTest("ä¿ç•™æœ€é‡è¦ç­–ç•¥", importantResult.isSome())
        
        // æµ‹è¯•æ‰¹é‡åˆå¹¶
        let allMemories = [memory1, memory2, memory3]
        let batchResults = merger.batchMergeMemories(allMemories)
        recordTest("æ‰¹é‡åˆå¹¶", batchResults.size >= 0)
        
        // æµ‹è¯•å†…å®¹èåˆ
        let fusedContent = merger.fuseContent(memoryGroup)
        recordTest("å†…å®¹èåˆ", fusedContent.size > 0)
        
        // æµ‹è¯•åˆå¹¶ç»Ÿè®¡
        let mergeStats = merger.getMergeStatistics()
        recordTest("åˆå¹¶ç»Ÿè®¡ä¿¡æ¯", mergeStats.size > 0)
        
        println("è®°å¿†åˆå¹¶ç­–ç•¥æµ‹è¯•å®Œæˆ")
    }
    
    /**
     * æµ‹è¯•è‡ªåŠ¨å»é‡æœºåˆ¶
     */
    private func testMemoryDeduplication(): Unit {
        println("\n--- æµ‹è¯•è‡ªåŠ¨å»é‡æœºåˆ¶ ---")
        
        // åˆ›å»ºå»é‡å™¨
        let config = DeduplicationConfig(DeduplicationPriority.INTELLIGENT, 0.85, 100)
        let detector = SemanticSimilarityDetector()
        let merger = MemoryMerger()
        let deduplicator = MemoryDeduplicator(config, detector, merger)
        
        // åˆ›å»ºåŒ…å«é‡å¤çš„è®°å¿†åˆ—è¡¨
        let memories = ArrayList<MemoryRecord>()
        
        // æ·»åŠ é‡å¤è®°å¿†
        memories.add(createTestMemory("dup_1", "æˆ‘å–œæ¬¢å–å’–å•¡", "user1"))
        memories.add(createTestMemory("dup_2", "æˆ‘å¾ˆå–œæ¬¢å–å’–å•¡", "user1"))
        memories.add(createTestMemory("dup_3", "æˆ‘å–œæ¬¢å–èŒ¶", "user1"))
        memories.add(createTestMemory("dup_4", "æˆ‘éå¸¸å–œæ¬¢å–èŒ¶", "user1"))
        memories.add(createTestMemory("dup_5", "ä»Šå¤©å¤©æ°”å¾ˆå¥½", "user1"))
        memories.add(createTestMemory("dup_6", "æˆ‘å­¦ä¹ ç¼–ç¨‹", "user1"))
        
        let memoryArray = memories.toArray()
        
        // æµ‹è¯•å»é‡å¤„ç†
        let (deduplicationResult, processedMemories) = deduplicator.deduplicateMemories(memoryArray)
        
        recordTest("å»é‡å¤„ç†æ‰§è¡Œ", deduplicationResult.originalCount == 6)
        recordTest("å»é‡åæ•°é‡å‡å°‘", processedMemories.size <= memoryArray.size)
        recordTest("å»é‡ç‡è®¡ç®—", deduplicationResult.deduplicationRate >= 0.0)
        
        // æµ‹è¯•å¿«é€Ÿé‡å¤æ£€æŸ¥
        let hasDuplicates = deduplicator.haseDuplicates(memoryArray)
        recordTest("å¿«é€Ÿé‡å¤æ£€æŸ¥", hasDuplicates)
        
        // æµ‹è¯•æ‰¹é‡å»é‡
        let (batchResult, batchProcessed) = deduplicator.batchDeduplicate(memoryArray)
        recordTest("æ‰¹é‡å»é‡å¤„ç†", batchResult.originalCount > 0)
        
        // æµ‹è¯•å»é‡ç»Ÿè®¡
        let dedupStats = deduplicator.getDeduplicationStatistics()
        recordTest("å»é‡ç»Ÿè®¡ä¿¡æ¯", dedupStats.size > 0 && dedupStats.contains("total_processed"))
        
        // æµ‹è¯•å»é‡å†å²
        let dedupHistory = deduplicator.getDeduplicationHistory()
        recordTest("å»é‡å†å²è®°å½•", dedupHistory.size > 0)
        
        println("è‡ªåŠ¨å»é‡æœºåˆ¶æµ‹è¯•å®Œæˆ")
    }
    
    /**
     * æµ‹è¯•å†²çªå¤„ç†
     */
    private func testConflictResolution(): Unit {
        println("\n--- æµ‹è¯•å†²çªå¤„ç† ---")
        
        // åˆ›å»ºå†²çªè§£å†³å™¨
        let config = ConflictResolverConfig()
        let detector = SemanticSimilarityDetector()
        let resolver = ConflictResolver(config, detector)
        
        // åˆ›å»ºå†²çªè®°å¿†
        let conflictMemory1 = createTestMemory("conflict_1", "æˆ‘å–œæ¬¢å–å’–å•¡", "user1")
        let conflictMemory2 = createTestMemory("conflict_2", "æˆ‘ä¸å–œæ¬¢å–å’–å•¡", "user1")
        let conflictMemory3 = createTestMemory("conflict_3", "æˆ‘ä½åœ¨åŒ—äº¬", "user1")
        let conflictMemory4 = createTestMemory("conflict_4", "æˆ‘ä½åœ¨ä¸Šæµ·", "user1")
        
        let conflictMemories = [conflictMemory1, conflictMemory2, conflictMemory3, conflictMemory4]
        
        // æµ‹è¯•å†²çªæ£€æµ‹
        let conflicts = resolver.detectConflicts(conflictMemories)
        recordTest("å†²çªæ£€æµ‹", conflicts.size >= 0)
        
        // å¦‚æœæ£€æµ‹åˆ°å†²çªï¼Œæµ‹è¯•å†²çªè§£å†³
        if (conflicts.size > 0) {
            let conflict = conflicts[0]
            
            // æµ‹è¯•è‡ªåŠ¨å†²çªè§£å†³
            let resolutionResult = resolver.resolveConflict(conflict, None)
            recordTest("è‡ªåŠ¨å†²çªè§£å†³", resolutionResult.isSome())
            
            if (resolutionResult.isSome()) {
                let result = resolutionResult.getOrThrow()
                recordTest("è§£å†³ç»“æœæœ‰æ•ˆ", result.resolvedMemories.size > 0)
                recordTest("è§£å†³ç½®ä¿¡åº¦åˆç†", result.confidence > 0.0)
            }
        }
        
        // æµ‹è¯•æ‰¹é‡å†²çªè§£å†³
        let batchResolutions = resolver.batchResolveConflicts(conflicts)
        recordTest("æ‰¹é‡å†²çªè§£å†³", batchResolutions.size >= 0)
        
        // æµ‹è¯•å¾…å®¡æ ¸å†²çª
        let pendingReviews = resolver.getPendingManualReviews()
        recordTest("å¾…å®¡æ ¸å†²çªè·å–", pendingReviews.size >= 0)
        
        // æµ‹è¯•å†²çªç»Ÿè®¡
        let conflictStats = resolver.getConflictStatistics()
        recordTest("å†²çªç»Ÿè®¡ä¿¡æ¯", conflictStats.size > 0)
        
        // æµ‹è¯•å†²çªå†å²
        let conflictHistory = resolver.getConflictHistory()
        recordTest("å†²çªå†å²è®°å½•", conflictHistory.size >= 0)
        
        println("å†²çªå¤„ç†æµ‹è¯•å®Œæˆ")
    }
    
    /**
     * æµ‹è¯•é›†æˆå»é‡å·¥ä½œæµ
     */
    private func testIntegratedDeduplicationWorkflow(): Unit {
        println("\n--- æµ‹è¯•é›†æˆå»é‡å·¥ä½œæµ ---")
        
        // åˆ›å»ºå®Œæ•´çš„å»é‡å·¥ä½œæµ
        let similarityDetector = SemanticSimilarityDetector()
        let memoryMerger = MemoryMerger()
        let deduplicator = MemoryDeduplicator()
        let conflictResolver = ConflictResolver()
        
        // åˆ›å»ºå¤æ‚çš„æµ‹è¯•æ•°æ®é›†
        let testMemories = createComplexTestDataset()
        
        // æ­¥éª¤1ï¼šæ£€æµ‹ç›¸ä¼¼æ€§
        let duplicateGroups = similarityDetector.detectDuplicateGroups(testMemories)
        recordTest("é›†æˆå·¥ä½œæµ-ç›¸ä¼¼æ€§æ£€æµ‹", duplicateGroups.size >= 0)
        
        // æ­¥éª¤2ï¼šæ‰§è¡Œå»é‡
        let (dedupResult, dedupedMemories) = deduplicator.deduplicateMemories(testMemories)
        recordTest("é›†æˆå·¥ä½œæµ-å»é‡æ‰§è¡Œ", dedupResult.finalCount <= dedupResult.originalCount)
        
        // æ­¥éª¤3ï¼šæ£€æµ‹å†²çª
        let conflicts = conflictResolver.detectConflicts(dedupedMemories)
        recordTest("é›†æˆå·¥ä½œæµ-å†²çªæ£€æµ‹", conflicts.size >= 0)
        
        // æ­¥éª¤4ï¼šè§£å†³å†²çª
        let resolutions = conflictResolver.batchResolveConflicts(conflicts)
        recordTest("é›†æˆå·¥ä½œæµ-å†²çªè§£å†³", resolutions.size >= 0)
        
        // éªŒè¯æœ€ç»ˆç»“æœ
        recordTest("é›†æˆå·¥ä½œæµ-æœ€ç»ˆæ•°é‡åˆç†", dedupedMemories.size > 0)
        
        println("é›†æˆå»é‡å·¥ä½œæµæµ‹è¯•å®Œæˆ")
    }
    
    /**
     * æµ‹è¯•æ€§èƒ½æŒ‡æ ‡
     */
    private func testPerformanceMetrics(): Unit {
        println("\n--- æµ‹è¯•æ€§èƒ½æŒ‡æ ‡ ---")
        
        // åˆ›å»ºå¤§é‡æµ‹è¯•æ•°æ®
        let largeDataset = createLargeTestDataset(1000)  // 1000æ¡è®°å¿†
        
        let startTime = DateTime.now().toUnixTimeStamp()
        
        // æµ‹è¯•å¤§æ•°æ®é›†å»é‡æ€§èƒ½
        let deduplicator = MemoryDeduplicator()
        let (perfResult, _) = deduplicator.batchDeduplicate(largeDataset)
        
        let endTime = DateTime.now().toUnixTimeStamp()
        let processingTime = endTime - startTime
        
        // éªŒè¯æ€§èƒ½æŒ‡æ ‡
        let processingSpeed = Float64(perfResult.originalCount) / Float64(processingTime) * 1000.0  // è®°å¿†/ç§’
        recordTest("å»é‡å¤„ç†é€Ÿåº¦ > 100è®°å¿†/ç§’", processingSpeed > 100.0)
        
        // éªŒè¯å»é‡å‡†ç¡®ç‡
        recordTest("å»é‡ç‡ > 10%", perfResult.deduplicationRate > 10.0)
        
        // éªŒè¯å†…å­˜ä½¿ç”¨åˆç†
        recordTest("å¤„ç†æ—¶é—´åˆç†", processingTime < 10000)  // å°äº10ç§’
        
        println("æ€§èƒ½æŒ‡æ ‡æµ‹è¯•å®Œæˆ")
        println("  - å¤„ç†é€Ÿåº¦: ${processingSpeed} è®°å¿†/ç§’")
        println("  - å»é‡ç‡: ${perfResult.deduplicationRate}%")
        println("  - å¤„ç†æ—¶é—´: ${processingTime}ms")
    }
    
    // ===== è¾…åŠ©æ–¹æ³• =====
    
    /**
     * åˆ›å»ºæµ‹è¯•è®°å¿†
     */
    private func createTestMemory(id: String, content: String, userId: String): MemoryRecord {
        let metadata = HashMap<String, String>()
        metadata["source"] = "test"
        metadata["type"] = "test_memory"
        
        return MemoryRecord(id, content, userId, DateTime.now().toUnixTimeStamp(), metadata)
    }
    
    /**
     * åˆ›å»ºå¤æ‚æµ‹è¯•æ•°æ®é›†
     */
    private func createComplexTestDataset(): Array<MemoryRecord> {
        let memories = ArrayList<MemoryRecord>()
        
        // æ·»åŠ ç›¸ä¼¼è®°å¿†ç»„
        memories.add(createTestMemory("complex_1", "æˆ‘å–œæ¬¢å–å’–å•¡", "user1"))
        memories.add(createTestMemory("complex_2", "æˆ‘å¾ˆå–œæ¬¢å–å’–å•¡", "user1"))
        memories.add(createTestMemory("complex_3", "å’–å•¡æ˜¯æˆ‘çš„æœ€çˆ±", "user1"))
        
        // æ·»åŠ å¦ä¸€ç»„ç›¸ä¼¼è®°å¿†
        memories.add(createTestMemory("complex_4", "æˆ‘ä½åœ¨åŒ—äº¬", "user1"))
        memories.add(createTestMemory("complex_5", "æˆ‘çš„å®¶åœ¨åŒ—äº¬", "user1"))
        
        // æ·»åŠ å†²çªè®°å¿†
        memories.add(createTestMemory("complex_6", "æˆ‘ä¸å–œæ¬¢å–å’–å•¡", "user1"))
        memories.add(createTestMemory("complex_7", "æˆ‘ä½åœ¨ä¸Šæµ·", "user1"))
        
        // æ·»åŠ ç‹¬ç‰¹è®°å¿†
        memories.add(createTestMemory("complex_8", "ä»Šå¤©å¤©æ°”å¾ˆå¥½", "user1"))
        memories.add(createTestMemory("complex_9", "æˆ‘åœ¨å­¦ä¹ ç¼–ç¨‹", "user1"))
        memories.add(createTestMemory("complex_10", "æ˜å¤©è¦å¼€ä¼š", "user1"))
        
        return memories.toArray()
    }
    
    /**
     * åˆ›å»ºå¤§å‹æµ‹è¯•æ•°æ®é›†
     */
    private func createLargeTestDataset(size: Int64): Array<MemoryRecord> {
        let memories = ArrayList<MemoryRecord>()
        
        let baseContents = [
            "æˆ‘å–œæ¬¢å–å’–å•¡",
            "æˆ‘ä½åœ¨åŒ—äº¬",
            "ä»Šå¤©å¤©æ°”å¾ˆå¥½",
            "æˆ‘åœ¨å­¦ä¹ ç¼–ç¨‹",
            "æˆ‘å–œæ¬¢çœ‹ç”µå½±",
            "æˆ‘ç»å¸¸è¿åŠ¨",
            "æˆ‘å–œæ¬¢è¯»ä¹¦",
            "æˆ‘å–œæ¬¢æ—…è¡Œ",
            "æˆ‘å–œæ¬¢éŸ³ä¹",
            "æˆ‘å–œæ¬¢ç¾é£Ÿ"
        ]
        
        for (i in 0..size) {
            let baseIndex = i % Int64(baseContents.size)
            let content = baseContents[baseIndex] + " " + i.toString()
            memories.add(createTestMemory("large_${i}", content, "user1"))
        }
        
        return memories.toArray()
    }
    
    /**
     * è®°å½•æµ‹è¯•ç»“æœ
     */
    private func recordTest(testName: String, result: Bool): Unit {
        testResults[testName] = result
        testCount = testCount + 1
        if (result) {
            passedCount = passedCount + 1
            println("âœ… ${testName}: é€šè¿‡")
        } else {
            println("âŒ ${testName}: å¤±è´¥")
        }
    }
    
    /**
     * æ‰“å°æµ‹è¯•ç»“æœæ‘˜è¦
     */
    private func printTestResults(): Unit {
        println("\n=== Phase 1.4 æµ‹è¯•ç»“æœæ‘˜è¦ ===")
        println("æ€»æµ‹è¯•æ•°: ${testCount}")
        println("é€šè¿‡æ•°: ${passedCount}")
        println("å¤±è´¥æ•°: ${testCount - passedCount}")
        println("é€šè¿‡ç‡: ${(Float64(passedCount) / Float64(testCount) * 100.0).toString()}%")
        
        if (passedCount == testCount) {
            println("ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼Phase 1.4 è®°å¿†åˆå¹¶å’Œå»é‡å®ç°æˆåŠŸï¼")
        } else {
            println("âš ï¸  éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œéœ€è¦è¿›ä¸€æ­¥æ£€æŸ¥")
        }
        
        println("=== Phase 1.4 æµ‹è¯•å®Œæˆ ===")
    }
}
