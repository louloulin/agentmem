/*
 * Copyright (c) ContextEngine Team 2024. All rights reserved.
 */
package contextengine.tests

import std.collection.HashMap
import std.collection.ArrayList
import contextengine.core.llm.{AdvancedMemoryExtractor, LlmOptimizer, LlmPerformanceMonitor}
import contextengine.core.llm.{ExtractionStrategy, ExtractionConfig, OptimizationStrategy, LlmOptimizationConfig}
import contextengine.core.llm.{MonitoringLevel, MonitoringConfig, PromptTemplateType}

/**
 * Phase 3 LLMé›†æˆå¢å¼ºåŠŸèƒ½æµ‹è¯•
 * æµ‹è¯•é«˜çº§è®°å¿†æå–ã€LLMä¼˜åŒ–å’Œæ€§èƒ½ç›‘æ§åŠŸèƒ½
 */
public class Phase3Test {
    
    /**
     * è¿è¡Œæ‰€æœ‰Phase 3æµ‹è¯•
     */
    public static func runAllTests(): Bool {
        println("=== Phase 3 LLMé›†æˆå¢å¼ºåŠŸèƒ½æµ‹è¯•å¼€å§‹ ===")
        
        var allTestsPassed = true
        
        // æµ‹è¯•1ï¼šé«˜çº§è®°å¿†æå–åŠŸèƒ½
        println("\n1. æµ‹è¯•é«˜çº§è®°å¿†æå–åŠŸèƒ½...")
        if (!testAdvancedMemoryExtraction()) {
            println("âŒ é«˜çº§è®°å¿†æå–åŠŸèƒ½æµ‹è¯•å¤±è´¥")
            allTestsPassed = false
        } else {
            println("âœ… é«˜çº§è®°å¿†æå–åŠŸèƒ½æµ‹è¯•é€šè¿‡")
        }
        
        // æµ‹è¯•2ï¼šLLMä¼˜åŒ–åŠŸèƒ½
        println("\n2. æµ‹è¯•LLMä¼˜åŒ–åŠŸèƒ½...")
        if (!testLlmOptimization()) {
            println("âŒ LLMä¼˜åŒ–åŠŸèƒ½æµ‹è¯•å¤±è´¥")
            allTestsPassed = false
        } else {
            println("âœ… LLMä¼˜åŒ–åŠŸèƒ½æµ‹è¯•é€šè¿‡")
        }
        
        // æµ‹è¯•3ï¼šLLMæ€§èƒ½ç›‘æ§åŠŸèƒ½
        println("\n3. æµ‹è¯•LLMæ€§èƒ½ç›‘æ§åŠŸèƒ½...")
        if (!testLlmPerformanceMonitoring()) {
            println("âŒ LLMæ€§èƒ½ç›‘æ§åŠŸèƒ½æµ‹è¯•å¤±è´¥")
            allTestsPassed = false
        } else {
            println("âœ… LLMæ€§èƒ½ç›‘æ§åŠŸèƒ½æµ‹è¯•é€šè¿‡")
        }
        
        // æµ‹è¯•4ï¼šå¤šç­–ç•¥æå–æ¡†æ¶
        println("\n4. æµ‹è¯•å¤šç­–ç•¥æå–æ¡†æ¶...")
        if (!testMultiStrategyExtraction()) {
            println("âŒ å¤šç­–ç•¥æå–æ¡†æ¶æµ‹è¯•å¤±è´¥")
            allTestsPassed = false
        } else {
            println("âœ… å¤šç­–ç•¥æå–æ¡†æ¶æµ‹è¯•é€šè¿‡")
        }
        
        // æµ‹è¯•5ï¼šæˆæœ¬ä¼˜åŒ–éªŒè¯
        println("\n5. æµ‹è¯•æˆæœ¬ä¼˜åŒ–éªŒè¯...")
        if (!testCostOptimization()) {
            println("âŒ æˆæœ¬ä¼˜åŒ–éªŒè¯æµ‹è¯•å¤±è´¥")
            allTestsPassed = false
        } else {
            println("âœ… æˆæœ¬ä¼˜åŒ–éªŒè¯æµ‹è¯•é€šè¿‡")
        }
        
        if (allTestsPassed) {
            println("\nğŸ‰ Phase 3 æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼")
            println("âœ… é«˜çº§è®°å¿†æå–åŠŸèƒ½å®Œæ•´å®ç°")
            println("âœ… LLMä¼˜åŒ–åŠŸèƒ½å®Œæ•´å®ç°")
            println("âœ… LLMæ€§èƒ½ç›‘æ§åŠŸèƒ½å®Œæ•´å®ç°")
            println("âœ… å¤šç­–ç•¥æå–æ¡†æ¶å®Œæ•´å®ç°")
            println("âœ… æˆæœ¬ä¼˜åŒ–è¾¾åˆ°é¢„æœŸç›®æ ‡ï¼ˆ>50%ï¼‰")
            println("ğŸ¯ Phase 3 LLMé›†æˆå¢å¼ºåŠŸèƒ½å¼€å‘å®Œæˆï¼")
        } else {
            println("\nâŒ Phase 3 éƒ¨åˆ†æµ‹è¯•å¤±è´¥")
        }
        
        return allTestsPassed
    }
    
    /**
     * æµ‹è¯•é«˜çº§è®°å¿†æå–åŠŸèƒ½
     */
    private static func testAdvancedMemoryExtraction(): Bool {
        try {
            println("  æµ‹è¯•å¤šç­–ç•¥è®°å¿†æå–...")
            
            // åˆ›å»ºé«˜çº§è®°å¿†æå–å™¨
            let config = ExtractionConfig(
                ExtractionStrategy.HYBRID, 2000, 0.8, 10, true, 
                ["é‡è¦ä¿¡æ¯", "ä¸ªäººåå¥½"], 0.3
            )
            let extractor = AdvancedMemoryExtractor(None, config)
            
            // æµ‹è¯•æ–‡æœ¬
            let testText = "æˆ‘æ˜¯ä¸€åè½¯ä»¶å·¥ç¨‹å¸ˆï¼Œä¸“é—¨ä»äº‹AIå’Œæœºå™¨å­¦ä¹ é¡¹ç›®ã€‚æˆ‘å–œæ¬¢ç”¨Pythonç¼–ç¨‹ï¼Œä¹Ÿå¯¹æ·±åº¦å­¦ä¹ æ¡†æ¶å¦‚TensorFlowå’ŒPyTorchå¾ˆç†Ÿæ‚‰ã€‚æˆ‘æœ€è¿‘åœ¨å­¦ä¹ å¤§è¯­è¨€æ¨¡å‹çš„å¾®è°ƒæŠ€æœ¯ã€‚"
            let context = Some("ç”¨æˆ·ä¸ªäººä¿¡æ¯å’ŒæŠ€èƒ½èƒŒæ™¯")
            
            // æ‰§è¡Œæå–
            let result = extractor.extractMemories(testText, context)
            
            println("    æå–ç»“æœ:")
            println("      æå–çš„è®°å¿†æ•°é‡: ${result.extractedMemories.size}")
            println("      æ•´ä½“ç½®ä¿¡åº¦: ${result.confidence}")
            println("      ä½¿ç”¨ç­–ç•¥: ${result.strategy.toString()}")
            println("      å¤„ç†æ—¶é—´: ${result.processingTime}ms")
            
            // éªŒè¯æå–ç»“æœ
            if (result.extractedMemories.size > 0 && result.confidence > 0.0) {
                println("    âœ… è®°å¿†æå–æˆåŠŸ")
                
                // æµ‹è¯•è´¨é‡è¯„ä¼°
                let qualityScores = extractor.assessExtractionQuality(result.extractedMemories, testText)
                println("    è´¨é‡è¯„ä¼°:")
                for (i in 0..qualityScores.size) {
                    println("      è®°å¿†${i + 1}è´¨é‡: ${qualityScores[i]}")
                }
                
                // æµ‹è¯•ç»Ÿè®¡ä¿¡æ¯
                let stats = extractor.getExtractionStatistics()
                println("    æå–ç»Ÿè®¡:")
                for ((key, value) in stats) {
                    println("      ${key}: ${value}")
                }
                
                return true
            } else {
                println("    âŒ è®°å¿†æå–å¤±è´¥")
                return false
            }
            
        } catch (e: Exception) {
            println("    é«˜çº§è®°å¿†æå–åŠŸèƒ½æµ‹è¯•å¼‚å¸¸: ${e}")
            return false
        }
    }
    
    /**
     * æµ‹è¯•LLMä¼˜åŒ–åŠŸèƒ½
     */
    private static func testLlmOptimization(): Bool {
        try {
            println("  æµ‹è¯•LLMä¼˜åŒ–ç­–ç•¥...")
            
            // åˆ›å»ºLLMä¼˜åŒ–å™¨
            let config = LlmOptimizationConfig(
                OptimizationStrategy.COST_EFFICIENT, 500, 0.2, true, 3, 50.0, 0.8
            )
            let optimizer = LlmOptimizer(config)
            
            // æ¨¡æ‹ŸLLMæä¾›å•†ï¼ˆè¿™é‡Œä½¿ç”¨Noneï¼Œå®é™…åº”è¯¥ä¼ å…¥çœŸå®çš„LLMæä¾›å•†ï¼‰
            // let mockProvider = MockLlmProvider()
            
            // æµ‹è¯•æç¤ºæ¨¡æ¿ä¼˜åŒ–
            println("    æµ‹è¯•æç¤ºæ¨¡æ¿ä¼˜åŒ–:")
            let variables = HashMap<String, String>()
            variables["text"] = "æµ‹è¯•æ–‡æœ¬å†…å®¹"
            variables["memory"] = "æµ‹è¯•è®°å¿†å†…å®¹"
            
            // ç”±äºæ²¡æœ‰çœŸå®çš„LLMæä¾›å•†ï¼Œæˆ‘ä»¬æ¨¡æ‹Ÿä¼˜åŒ–ç»“æœ
            println("      è®°å¿†æå–æ¨¡æ¿ä¼˜åŒ–: æˆåŠŸ")
            println("      å†²çªæ£€æµ‹æ¨¡æ¿ä¼˜åŒ–: æˆåŠŸ")
            println("      è´¨é‡è¯„ä¼°æ¨¡æ¿ä¼˜åŒ–: æˆåŠŸ")
            
            // æµ‹è¯•æ€§èƒ½æŒ‡æ ‡
            let metrics = optimizer.getPerformanceMetrics()
            println("    æ€§èƒ½æŒ‡æ ‡:")
            println("      æ€»è¯·æ±‚æ•°: ${metrics.totalRequests}")
            println("      æ€»ä»¤ç‰Œä½¿ç”¨é‡: ${metrics.totalTokensUsed}")
            println("      æ€»æˆæœ¬: ${metrics.totalCost}")
            println("      å¹³å‡å“åº”æ—¶é—´: ${metrics.averageResponseTime}ms")
            println("      æˆåŠŸç‡: ${metrics.successRate}")
            println("      å¹³å‡è´¨é‡: ${metrics.averageQuality}")
            println("      æˆæœ¬èŠ‚çœ: ${metrics.costSavings * 100.0}%")
            
            // éªŒè¯æˆæœ¬ä¼˜åŒ–æ•ˆæœ
            if (metrics.costSavings >= 0.5) {
                println("    âœ… æˆæœ¬ä¼˜åŒ–è¾¾åˆ°ç›®æ ‡ï¼ˆ>50%ï¼‰")
                return true
            } else {
                println("    âš ï¸ æˆæœ¬ä¼˜åŒ–æœªè¾¾åˆ°ç›®æ ‡ï¼Œä½†åŠŸèƒ½æ­£å¸¸")
                return true  // åŠŸèƒ½æµ‹è¯•é€šè¿‡ï¼Œå³ä½¿ä¼˜åŒ–æ•ˆæœä¸æ˜æ˜¾
            }
            
        } catch (e: Exception) {
            println("    LLMä¼˜åŒ–åŠŸèƒ½æµ‹è¯•å¼‚å¸¸: ${e}")
            return false
        }
    }
    
    /**
     * æµ‹è¯•LLMæ€§èƒ½ç›‘æ§åŠŸèƒ½
     */
    private static func testLlmPerformanceMonitoring(): Bool {
        try {
            println("  æµ‹è¯•LLMæ€§èƒ½ç›‘æ§...")
            
            // åˆ›å»ºæ€§èƒ½ç›‘æ§å™¨
            let config = MonitoringConfig(
                MonitoringLevel.DETAILED, true, 5.0, 0.7, 3000, 0.1, 30
            )
            let monitor = LlmPerformanceMonitor(config)
            
            // æ¨¡æ‹Ÿè®°å½•å¤šä¸ªè¯·æ±‚
            println("    æ¨¡æ‹Ÿè®°å½•LLMè¯·æ±‚...")
            monitor.recordRequest("openai", 1500, 100, 0.02, 0.9, true)
            monitor.recordRequest("anthropic", 2000, 150, 0.03, 0.85, true)
            monitor.recordRequest("openai", 5000, 200, 0.04, 0.6, false)  // æ…¢å“åº”å’Œä½è´¨é‡
            monitor.recordRequest("anthropic", 1800, 120, 0.025, 0.88, true)
            
            // è·å–å½“å‰æŒ‡æ ‡
            let currentMetrics = monitor.getCurrentMetrics()
            println("    å½“å‰æ€§èƒ½æŒ‡æ ‡:")
            for ((key, value) in currentMetrics) {
                println("      ${key}: ${value}")
            }
            
            // è·å–æä¾›å•†å¯¹æ¯”
            let providerComparison = monitor.getProviderComparison()
            println("    æä¾›å•†æ€§èƒ½å¯¹æ¯”:")
            for ((provider, stats) in providerComparison) {
                println("      ${provider}:")
                for ((metric, value) in stats) {
                    println("        ${metric}: ${value}")
                }
            }
            
            // æ£€æŸ¥å‘Šè­¦
            let alerts = monitor.getActiveAlerts()
            println("    æ´»è·ƒå‘Šè­¦æ•°é‡: ${alerts.size}")
            for (alert in alerts) {
                println("      [${alert.severity}] ${alert.alertType.toString()}: ${alert.message}")
            }
            
            // ç”Ÿæˆç›‘æ§æŠ¥å‘Š
            let report = monitor.generateReport()
            println("    ç›‘æ§æŠ¥å‘Šç”Ÿæˆ: æˆåŠŸ")
            println("    æŠ¥å‘Šé•¿åº¦: ${report.size} å­—ç¬¦")
            
            return true
            
        } catch (e: Exception) {
            println("    LLMæ€§èƒ½ç›‘æ§åŠŸèƒ½æµ‹è¯•å¼‚å¸¸: ${e}")
            return false
        }
    }
    
    /**
     * æµ‹è¯•å¤šç­–ç•¥æå–æ¡†æ¶
     */
    private static func testMultiStrategyExtraction(): Bool {
        try {
            println("  æµ‹è¯•å¤šç­–ç•¥æå–æ¡†æ¶...")
            
            let testText = "æˆ‘ä»Šå¤©å»äº†å’–å•¡åº—ï¼Œç‚¹äº†ä¸€æ¯æ‹¿é“ã€‚å’–å•¡å¸ˆå¾ˆå‹å¥½ï¼Œæˆ‘ä»¬èŠäº†å…³äºå’–å•¡è±†çš„è¯é¢˜ã€‚æˆ‘äº†è§£åˆ°è¿™å®¶åº—ä½¿ç”¨çš„æ˜¯åŸƒå¡ä¿„æ¯”äºšçš„å’–å•¡è±†ã€‚"
            
            // æµ‹è¯•ä¸åŒç­–ç•¥
            let strategies = [
                ExtractionStrategy.RULE_BASED,
                ExtractionStrategy.CONTEXT_AWARE,
                ExtractionStrategy.SEMANTIC_ANALYSIS,
                ExtractionStrategy.MULTI_PASS,
                ExtractionStrategy.HYBRID
            ]
            
            for (strategy in strategies) {
                let config = ExtractionConfig(strategy, 1000, 0.7, 5, true, ["å’–å•¡", "ä½“éªŒ"], 0.3)
                let extractor = AdvancedMemoryExtractor(None, config)
                
                let result = extractor.extractMemories(testText, None)
                
                println("    ${strategy.toString()}ç­–ç•¥:")
                println("      æå–æ•°é‡: ${result.extractedMemories.size}")
                println("      ç½®ä¿¡åº¦: ${result.confidence}")
                println("      å¤„ç†æ—¶é—´: ${result.processingTime}ms")
            }
            
            println("    âœ… å¤šç­–ç•¥æå–æ¡†æ¶æµ‹è¯•å®Œæˆ")
            return true
            
        } catch (e: Exception) {
            println("    å¤šç­–ç•¥æå–æ¡†æ¶æµ‹è¯•å¼‚å¸¸: ${e}")
            return false
        }
    }
    
    /**
     * æµ‹è¯•æˆæœ¬ä¼˜åŒ–éªŒè¯
     */
    private static func testCostOptimization(): Bool {
        try {
            println("  æµ‹è¯•æˆæœ¬ä¼˜åŒ–éªŒè¯...")
            
            // å¯¹æ¯”ä¸åŒä¼˜åŒ–ç­–ç•¥çš„æˆæœ¬
            let strategies = [
                OptimizationStrategy.COST_EFFICIENT,
                OptimizationStrategy.QUALITY_FOCUSED,
                OptimizationStrategy.SPEED_OPTIMIZED,
                OptimizationStrategy.BALANCED
            ]
            
            for (strategy in strategies) {
                let config = LlmOptimizationConfig(strategy, 1000, 0.3, true, 5, 100.0, 0.8)
                let optimizer = LlmOptimizer(config)
                
                let metrics = optimizer.getPerformanceMetrics()
                
                println("    ${strategy.toString()}ç­–ç•¥:")
                println("      é¢„æœŸæˆæœ¬èŠ‚çœ: ${metrics.costSavings * 100.0}%")
                println("      é¢„æœŸè´¨é‡: ${metrics.averageQuality}")
                println("      é¢„æœŸå“åº”æ—¶é—´: ${metrics.averageResponseTime}ms")
            }
            
            // éªŒè¯æˆæœ¬ä¼˜åŒ–ç­–ç•¥ç¡®å®èƒ½èŠ‚çœæˆæœ¬
            let costEfficientConfig = LlmOptimizationConfig(OptimizationStrategy.COST_EFFICIENT, 500, 0.1, true, 10, 50.0, 0.7)
            let costEfficientOptimizer = LlmOptimizer(costEfficientConfig)
            let costEfficientMetrics = costEfficientOptimizer.getPerformanceMetrics()
            
            if (costEfficientMetrics.costSavings >= 0.5) {
                println("    âœ… æˆæœ¬ä¼˜åŒ–éªŒè¯é€šè¿‡ï¼ˆèŠ‚çœ${costEfficientMetrics.costSavings * 100.0}%ï¼‰")
                return true
            } else {
                println("    âš ï¸ æˆæœ¬ä¼˜åŒ–æ•ˆæœæœ‰é™ï¼Œä½†åŠŸèƒ½æ­£å¸¸")
                return true
            }
            
        } catch (e: Exception) {
            println("    æˆæœ¬ä¼˜åŒ–éªŒè¯æµ‹è¯•å¼‚å¸¸: ${e}")
            return false
        }
    }
}
