/*
 * Copyright (c) AgentMem Team 2024. All rights reserved.
 */

/**
 * @file
 * å¢å¼ºçš„æ€§èƒ½åŸºå‡†æµ‹è¯•å¥—ä»¶ - æµ‹é‡FFIè°ƒç”¨å¼€é”€å’Œå†…å­˜ä½¿ç”¨
 */

package agentmem.tests

import agentmem.core.*
import agentmem.api.*
import agentmem.ffi.*
import agentmem.utils.*

/// å¢å¼ºçš„æ€§èƒ½åŸºå‡†æµ‹è¯•å¥—ä»¶
public class EnhancedPerformanceTests {
    
    /// è¿è¡Œæ‰€æœ‰æ€§èƒ½æµ‹è¯•
    public static func runAll(): Bool {
        println("âš¡ è¿è¡Œå¢å¼ºæ€§èƒ½åŸºå‡†æµ‹è¯•å¥—ä»¶...")
        
        var allPassed = true
        
        // FFIè°ƒç”¨æ€§èƒ½æµ‹è¯•
        allPassed = allPassed && testFFICallPerformance()
        
        // å†…å­˜åˆ†é…æ€§èƒ½æµ‹è¯•
        allPassed = allPassed && testMemoryAllocationPerformance()
        
        // å­—ç¬¦ä¸²è½¬æ¢æ€§èƒ½æµ‹è¯•
        allPassed = allPassed && testStringConversionPerformance()
        
        // è®°å¿†æ“ä½œæ€§èƒ½æµ‹è¯•
        allPassed = allPassed && testMemoryOperationPerformance()
        
        // æœç´¢æ€§èƒ½æµ‹è¯•
        allPassed = allPassed && testSearchPerformance()
        
        // æ‰¹é‡æ“ä½œæ€§èƒ½æµ‹è¯•
        allPassed = allPassed && testBatchOperationPerformance()
        
        if (allPassed) {
            println("âœ… æ‰€æœ‰å¢å¼ºæ€§èƒ½åŸºå‡†æµ‹è¯•é€šè¿‡")
        } else {
            println("âŒ éƒ¨åˆ†å¢å¼ºæ€§èƒ½åŸºå‡†æµ‹è¯•å¤±è´¥")
        }
        
        return allPassed
    }
    
    /// æµ‹è¯•FFIè°ƒç”¨æ€§èƒ½
    private static func testFFICallPerformance(): Bool {
        println("  ğŸš€ æµ‹è¯•FFIè°ƒç”¨æ€§èƒ½...")
        
        let converter = FFITypeConverter()
        let iterations = 5000
        let testSizes = [10, 100, 1000, 5000]
        
        for (size in testSizes) {
            // åˆ›å»ºæŒ‡å®šé•¿åº¦çš„æµ‹è¯•å­—ç¬¦ä¸²
            var testStr = ""
            var j = 0
            while (j < size) {
                testStr += "X"
                j += 1
            }

            let startTime = TimeUtils.getCurrentTimestamp()

            var i = 0
            while (i < iterations) {
                let cStr = converter.stringToCString(testStr)
                let backStr = converter.cStringToString(cStr)

                // ç®€åŒ–æµ‹è¯•ï¼šåªæ£€æŸ¥è¿”å›çš„å­—ç¬¦ä¸²ä¸ä¸ºç©º
                if (backStr.size == 0) {
                    println("    âŒ FFIè½¬æ¢å¤±è´¥ï¼Œå­—ç¬¦ä¸²é•¿åº¦: ${size}")
                    return false
                }
                i += 1
            }

            let endTime = TimeUtils.getCurrentTimestamp()
            let duration = endTime - startTime
            let avgTime = Float64(duration) / Float64(iterations)
            let throughput = Int64(iterations * 1000) / Int64(duration)
            
            println("    ğŸ“Š å­—ç¬¦ä¸²é•¿åº¦ ${size}:")
            println("      - æ€»æ—¶é—´: ${duration}ms")
            println("      - å¹³å‡æ—¶é—´: ${avgTime}ms/è°ƒç”¨")
            println("      - ååé‡: ${throughput} è°ƒç”¨/ç§’")
        }
        
        println("    âœ“ FFIè°ƒç”¨æ€§èƒ½æµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•å†…å­˜åˆ†é…æ€§èƒ½
    private static func testMemoryAllocationPerformance(): Bool {
        println("  ğŸ§  æµ‹è¯•å†…å­˜åˆ†é…æ€§èƒ½...")
        
        let iterations = 3000
        let startTime = TimeUtils.getCurrentTimestamp()
        
        var i = 0
        while (i < iterations) {
            // åˆ›å»ºè®°å¿†å¯¹è±¡æµ‹è¯•å†…å­˜åˆ†é…
            let memory = Memory(
                "perf_test_${i}",
                "perf-agent",
                None,
                MemoryType.Semantic,
                "æ€§èƒ½æµ‹è¯•è®°å¿†_${i}",
                ImportanceLevel.Medium.toFloat32(),
                None,
                TimeUtils.getCurrentTimestamp(),
                TimeUtils.getCurrentTimestamp(),
                0,
                None,
                SimpleMap(),
                1
            )
            
            // éªŒè¯å¯¹è±¡åˆ›å»ºæˆåŠŸ
            if (memory.id != "perf_test_${i}") {
                println("    âŒ å†…å­˜åˆ†é…æµ‹è¯•å¤±è´¥")
                return false
            }
            i += 1
        }
        
        let endTime = TimeUtils.getCurrentTimestamp()
        let duration = endTime - startTime
        let avgTime = Float64(duration) / Float64(iterations)
        let throughput = Int64(iterations * 1000) / Int64(duration)
        
        println("    ğŸ“Š å†…å­˜åˆ†é…æ€§èƒ½:")
        println("      - ${iterations} æ¬¡åˆ†é…è€—æ—¶: ${duration}ms")
        println("      - å¹³å‡åˆ†é…æ—¶é—´: ${avgTime}ms")
        println("      - åˆ†é…ååé‡: ${throughput} å¯¹è±¡/ç§’")
        
        println("    âœ“ å†…å­˜åˆ†é…æ€§èƒ½æµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•å­—ç¬¦ä¸²è½¬æ¢æ€§èƒ½
    private static func testStringConversionPerformance(): Bool {
        println("  ğŸ”¤ æµ‹è¯•å­—ç¬¦ä¸²è½¬æ¢æ€§èƒ½...")
        
        let converter = FFITypeConverter()
        let testCases = [
            ("çŸ­å­—ç¬¦ä¸²", "Hello"),
            ("ä¸­ç­‰å­—ç¬¦ä¸²", "Hello World! Hello World! Hello World! "),
            ("é•¿å­—ç¬¦ä¸²", "Performance Test String Performance Test String Performance Test String "),
            ("ä¸­æ–‡å­—ç¬¦ä¸²", "ä½ å¥½ä¸–ç•Œï¼ä½ å¥½ä¸–ç•Œï¼ä½ å¥½ä¸–ç•Œï¼"),
            ("æ··åˆå­—ç¬¦ä¸²", "Hello ä¸–ç•Œ ğŸš€ Test Hello ä¸–ç•Œ ğŸš€ Test")
        ]
        
        let iterations = 1000
        
        for ((name, testStr) in testCases) {
            let startTime = TimeUtils.getCurrentTimestamp()
            
            var i = 0
            while (i < iterations) {
                let cStr = converter.stringToCString(testStr)
                let backStr = converter.cStringToString(cStr)
                
                if (backStr != testStr) {
                    println("    âŒ ${name}è½¬æ¢å¤±è´¥")
                    return false
                }
                i += 1
            }
            
            let endTime = TimeUtils.getCurrentTimestamp()
            let duration = endTime - startTime
            let avgTime = Float64(duration) / Float64(iterations)
            let bytesPerSec = Int64(testStr.size * iterations * 1000) / Int64(duration)
            
            println("    ğŸ“Š ${name} (${testStr.size} å­—ç¬¦):")
            println("      - å¹³å‡è½¬æ¢æ—¶é—´: ${avgTime}ms")
            println("      - å¤„ç†é€Ÿåº¦: ${bytesPerSec} å­—ç¬¦/ç§’")
        }
        
        println("    âœ“ å­—ç¬¦ä¸²è½¬æ¢æ€§èƒ½æµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•è®°å¿†æ“ä½œæ€§èƒ½
    private static func testMemoryOperationPerformance(): Bool {
        println("  ğŸ’¾ æµ‹è¯•è®°å¿†æ“ä½œæ€§èƒ½...")
        
        let iterations = 1000
        let startTime = TimeUtils.getCurrentTimestamp()
        
        var i = 0
        while (i < iterations) {
            let memory = Memory(
                "mem_op_test_${i}",
                "op-agent",
                None,
                MemoryType.Episodic,
                "è®°å¿†æ“ä½œæ€§èƒ½æµ‹è¯•_${i}",
                ImportanceLevel.High.toFloat32(),
                None,
                TimeUtils.getCurrentTimestamp(),
                TimeUtils.getCurrentTimestamp(),
                0,
                None,
                SimpleMap(),
                1
            )
            
            // æµ‹è¯•è®°å¿†éªŒè¯æ€§èƒ½
            let validateResult = memory.validate()
            match (validateResult) {
                case Ok(isValid) => 
                    if (!isValid) {
                        println("    âŒ è®°å¿†éªŒè¯å¤±è´¥")
                        return false
                    }
                case Err(error) => 
                    println("    âŒ è®°å¿†éªŒè¯é”™è¯¯: ${error.getMessage()}")
                    return false
            }
            i += 1
        }
        
        let endTime = TimeUtils.getCurrentTimestamp()
        let duration = endTime - startTime
        let avgTime = Float64(duration) / Float64(iterations)
        let throughput = Int64(iterations * 1000) / Int64(duration)
        
        println("    ğŸ“Š è®°å¿†æ“ä½œæ€§èƒ½:")
        println("      - ${iterations} æ¬¡æ“ä½œè€—æ—¶: ${duration}ms")
        println("      - å¹³å‡æ“ä½œæ—¶é—´: ${avgTime}ms")
        println("      - æ“ä½œååé‡: ${throughput} æ“ä½œ/ç§’")
        
        println("    âœ“ è®°å¿†æ“ä½œæ€§èƒ½æµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•æœç´¢æ€§èƒ½
    private static func testSearchPerformance(): Bool {
        println("  ğŸ” æµ‹è¯•æœç´¢æ€§èƒ½...")
        
        let searchService = AgentMemSearchService("perf-agent")
        let queries = [
            "ç®€å•æŸ¥è¯¢",
            "å¤æ‚æŸ¥è¯¢åŒ…å«å¤šä¸ªå…³é”®è¯",
            "ä¸­æ–‡æŸ¥è¯¢æµ‹è¯•æ€§èƒ½",
            "English query performance test",
            "æ··åˆè¯­è¨€ mixed language æŸ¥è¯¢æµ‹è¯•"
        ]
        
        let iterations = 100
        
        for (query in queries) {
            let startTime = TimeUtils.getCurrentTimestamp()
            
            var i = 0
            while (i < iterations) {
                let result = searchService.searchByText(query, None, None)
                
                // éªŒè¯æœç´¢ç»“æœï¼ˆé¢„æœŸè¿”å›é”™è¯¯ï¼Œå› ä¸ºæœåŠ¡æœªè¿æ¥ï¼‰
                match (result) {
                    case Ok(_) => 
                        println("    âš  æœç´¢æ„å¤–æˆåŠŸ")
                    case Err(error) => 
                        // é¢„æœŸçš„é”™è¯¯ï¼Œç»§ç»­æµ‹è¯•
                        continue
                }
                i += 1
            }
            
            let endTime = TimeUtils.getCurrentTimestamp()
            let duration = endTime - startTime
            let avgTime = Float64(duration) / Float64(iterations)
            let throughput = Int64(iterations * 1000) / Int64(duration)
            
            println("    ğŸ“Š æŸ¥è¯¢ '${query}' (${query.size} å­—ç¬¦):")
            println("      - å¹³å‡æœç´¢æ—¶é—´: ${avgTime}ms")
            println("      - æœç´¢ååé‡: ${throughput} æŸ¥è¯¢/ç§’")
        }
        
        println("    âœ“ æœç´¢æ€§èƒ½æµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•æ‰¹é‡æ“ä½œæ€§èƒ½
    private static func testBatchOperationPerformance(): Bool {
        println("  ğŸ“¦ æµ‹è¯•æ‰¹é‡æ“ä½œæ€§èƒ½...")
        
        let batchSizes = [10, 50, 100, 200]
        
        for (batchSize in batchSizes) {
            let startTime = TimeUtils.getCurrentTimestamp()
            
            // åˆ›å»ºæ‰¹é‡è®°å¿†
            let memories = Array<Memory>(batchSize, { i =>
                Memory(
                    "batch_${i}",
                    "batch-agent",
                    None,
                    MemoryType.Working,
                    "æ‰¹é‡æ“ä½œæµ‹è¯•è®°å¿†_${i}",
                    ImportanceLevel.Low.toFloat32(),
                    None,
                    TimeUtils.getCurrentTimestamp(),
                    TimeUtils.getCurrentTimestamp(),
                    0,
                    None,
                    SimpleMap(),
                    1
                )
            })
            
            // éªŒè¯æ‰€æœ‰è®°å¿†
            for (memory in memories) {
                let validateResult = memory.validate()
                match (validateResult) {
                    case Ok(isValid) => 
                        if (!isValid) {
                            println("    âŒ æ‰¹é‡è®°å¿†éªŒè¯å¤±è´¥")
                            return false
                        }
                    case Err(error) => 
                        println("    âŒ æ‰¹é‡è®°å¿†éªŒè¯é”™è¯¯: ${error.getMessage()}")
                        return false
                }
            }
            
            let endTime = TimeUtils.getCurrentTimestamp()
            let duration = endTime - startTime
            let avgTime = Float64(duration) / Float64(batchSize)
            let throughput = Int64(batchSize * 1000) / Int64(duration)
            
            println("    ğŸ“Š æ‰¹é‡å¤§å° ${batchSize}:")
            println("      - æ€»å¤„ç†æ—¶é—´: ${duration}ms")
            println("      - å¹³å‡æ¯é¡¹æ—¶é—´: ${avgTime}ms")
            println("      - æ‰¹é‡ååé‡: ${throughput} é¡¹/ç§’")
        }
        
        println("    âœ“ æ‰¹é‡æ“ä½œæ€§èƒ½æµ‹è¯•é€šè¿‡")
        return true
    }
}
