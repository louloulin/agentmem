/*
 * Copyright (c) AgentMem Team 2024. All rights reserved.
 */

/**
 * @file
 * å…¨é¢çš„å•å…ƒæµ‹è¯•å¥—ä»¶ - ç¡®ä¿æ¯ä¸ªå…¬å…±APIéƒ½æœ‰å¯¹åº”æµ‹è¯•
 */

package agentmem.tests

import agentmem.core.*
import agentmem.api.*
import agentmem.ffi.*
import agentmem.utils.*

/// å…¨é¢çš„å•å…ƒæµ‹è¯•å¥—ä»¶
public class UnitTests {
    
    /// è¿è¡Œæ‰€æœ‰å•å…ƒæµ‹è¯•
    public static func runAll(): Bool {
        println("ğŸ§ª è¿è¡Œå…¨é¢å•å…ƒæµ‹è¯•å¥—ä»¶...")
        
        var allPassed = true
        
        // æ ¸å¿ƒç±»å‹æµ‹è¯•
        allPassed = allPassed && testMemoryTypes()
        allPassed = allPassed && testImportanceLevels()
        allPassed = allPassed && testErrorTypes()
        allPassed = allPassed && testConfigTypes()
        
        // APIå±‚æµ‹è¯•
        allPassed = allPassed && testClientBuilder()
        allPassed = allPassed && testSearchService()
        allPassed = allPassed && testMemoryOperations()
        
        // FFIå±‚æµ‹è¯•
        allPassed = allPassed && testFFIBindings()
        allPassed = allPassed && testMemoryManagement()
        allPassed = allPassed && testTypeConversions()
        
        // å·¥å…·å‡½æ•°æµ‹è¯•
        allPassed = allPassed && testUtilityFunctions()
        
        if (allPassed) {
            println("âœ… æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡")
        } else {
            println("âŒ éƒ¨åˆ†å•å…ƒæµ‹è¯•å¤±è´¥")
        }
        
        return allPassed
    }
    
    /// æµ‹è¯•è®°å¿†ç±»å‹
    private static func testMemoryTypes(): Bool {
        println("  ğŸ“ æµ‹è¯•è®°å¿†ç±»å‹...")
        
        // æµ‹è¯•æ‰€æœ‰è®°å¿†ç±»å‹
        let types = [
            MemoryType.Semantic,
            MemoryType.Episodic,
            MemoryType.Procedural,
            MemoryType.Working
        ]
        
        for (memType in types) {
            let typeStr = memType.toString()
            if (typeStr.isEmpty()) {
                println("    âŒ è®°å¿†ç±»å‹toStringå¤±è´¥")
                return false
            }
        }
        
        println("    âœ“ è®°å¿†ç±»å‹æµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•é‡è¦æ€§çº§åˆ«
    private static func testImportanceLevels(): Bool {
        println("  ğŸ“Š æµ‹è¯•é‡è¦æ€§çº§åˆ«...")
        
        // æµ‹è¯•æ‰€æœ‰é‡è¦æ€§çº§åˆ«
        let levels = [
            ImportanceLevel.Low,
            ImportanceLevel.Medium,
            ImportanceLevel.High,
            ImportanceLevel.Critical
        ]
        
        let expectedValues = [0.25, 0.5, 0.75, 1.0]
        
        for (i in 0..levels.size) {
            let level = levels[i]
            let value = level.toFloat32()
            let expected = Float32(expectedValues[i])
            
            let diff = if (value > expected) { value - expected } else { expected - value }
            if (diff > 0.001) {
                println("    âŒ é‡è¦æ€§çº§åˆ«å€¼é”™è¯¯: å€¼ = ${value}, æœŸæœ› ${expected}")
                return false
            }
        }
        
        println("    âœ“ é‡è¦æ€§çº§åˆ«æµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•é”™è¯¯ç±»å‹
    private static func testErrorTypes(): Bool {
        println("  ğŸš¨ æµ‹è¯•é”™è¯¯ç±»å‹...")
        
        // æµ‹è¯•å„ç§é”™è¯¯ç±»å‹
        let errors = [
            AgentMemError.InvalidParameter("æµ‹è¯•å‚æ•°é”™è¯¯"),
            AgentMemError.NotFound("æµ‹è¯•æœªæ‰¾åˆ°"),
            AgentMemError.NetworkError("æµ‹è¯•ç½‘ç»œé”™è¯¯"),
            AgentMemError.AuthenticationError("æµ‹è¯•è®¤è¯é”™è¯¯"),
            AgentMemError.AuthorizationError("æµ‹è¯•æƒé™é”™è¯¯"),
            AgentMemError.TimeoutError("æµ‹è¯•è¶…æ—¶é”™è¯¯"),
            AgentMemError.InternalError("æµ‹è¯•å†…éƒ¨é”™è¯¯")
        ]
        
        for (error in errors) {
            let message = error.getMessage()
            // ç®€åŒ–é”™è¯¯æµ‹è¯•ï¼Œä¸ä¾èµ–getCodeæ–¹æ³•
            let retryable = error.isRetryable()
            
            if (message.isEmpty()) {
                println("    âŒ é”™è¯¯æ¶ˆæ¯ä¸ºç©º")
                return false
            }
        }
        
        println("    âœ“ é”™è¯¯ç±»å‹æµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•é…ç½®ç±»å‹
    private static func testConfigTypes(): Bool {
        println("  âš™ï¸ æµ‹è¯•é…ç½®ç±»å‹...")
        
        // æµ‹è¯•å®¢æˆ·ç«¯é…ç½®
        let config = ClientConfig("http://test.example.com", "test-agent")
        
        if (config.serverUrl != "http://test.example.com") {
            println("    âŒ æœåŠ¡å™¨URLè®¾ç½®å¤±è´¥")
            return false
        }
        
        if (config.agentId != "test-agent") {
            println("    âŒ ä»£ç†IDè®¾ç½®å¤±è´¥")
            return false
        }
        
        // æµ‹è¯•é»˜è®¤å€¼
        if (config.timeout != 30) {
            println("    âŒ é»˜è®¤è¶…æ—¶æ—¶é—´é”™è¯¯")
            return false
        }
        
        if (config.retryCount != 3) {
            println("    âŒ é»˜è®¤é‡è¯•æ¬¡æ•°é”™è¯¯")
            return false
        }
        
        println("    âœ“ é…ç½®ç±»å‹æµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•å®¢æˆ·ç«¯æ„å»ºå™¨
    private static func testClientBuilder(): Bool {
        println("  ğŸ—ï¸ æµ‹è¯•å®¢æˆ·ç«¯æ„å»ºå™¨...")
        
        // æµ‹è¯•åŸºæœ¬æ„å»º
        let builderResult = AgentMemClientBuilder().build()
        
        match (builderResult) {
            case Ok(client) => 
                println("    âœ“ å®¢æˆ·ç«¯æ„å»ºæˆåŠŸ")
            case Err(error) => 
                println("    âš  å®¢æˆ·ç«¯æ„å»ºå¤±è´¥: ${error.getMessage()}")
                // è¿™æ˜¯é¢„æœŸçš„ï¼Œå› ä¸ºæ²¡æœ‰æä¾›å¿…è¦é…ç½®
        }
        
        println("    âœ“ å®¢æˆ·ç«¯æ„å»ºå™¨æµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•æœç´¢æœåŠ¡
    private static func testSearchService(): Bool {
        println("  ğŸ” æµ‹è¯•æœç´¢æœåŠ¡...")
        
        let searchService = AgentMemSearchService("test-agent")
        
        // æµ‹è¯•æ–‡æœ¬æœç´¢ï¼ˆåº”è¯¥è¿”å›æœªè¿æ¥é”™è¯¯ï¼‰
        let searchResult = searchService.searchByText("æµ‹è¯•æŸ¥è¯¢", None, None)
        
        match (searchResult) {
            case Ok(results) => 
                println("    âš  æœç´¢æ„å¤–æˆåŠŸ")
            case Err(error) =>
                // æ£€æŸ¥é”™è¯¯ç±»å‹ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
                println("    âœ“ æœç´¢æœåŠ¡æ­£ç¡®è¿”å›é”™è¯¯: ${error.getMessage()}")
        }
        
        println("    âœ“ æœç´¢æœåŠ¡æµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•è®°å¿†æ“ä½œ
    private static func testMemoryOperations(): Bool {
        println("  ğŸ’¾ æµ‹è¯•è®°å¿†æ“ä½œ...")
        
        // åˆ›å»ºæµ‹è¯•è®°å¿†
        let memory = Memory(
            "unit_test_001",
            "test-agent",
            None,
            MemoryType.Semantic,
            "è¿™æ˜¯ä¸€ä¸ªå•å…ƒæµ‹è¯•è®°å¿†",
            ImportanceLevel.Medium.toFloat32(),
            None,
            1640995200000,
            1640995200000,
            0,
            None,
            SimpleMap(),
            1
        )
        
        // æµ‹è¯•è®°å¿†éªŒè¯
        let validateResult = memory.validate()
        match (validateResult) {
            case Ok(isValid) => 
                if (isValid) {
                    println("    âœ“ è®°å¿†éªŒè¯é€šè¿‡")
                } else {
                    println("    âŒ è®°å¿†éªŒè¯å¤±è´¥")
                    return false
                }
            case Err(error) => 
                println("    âŒ è®°å¿†éªŒè¯é”™è¯¯: ${error.getMessage()}")
                return false
        }
        
        println("    âœ“ è®°å¿†æ“ä½œæµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•FFIç»‘å®š
    private static func testFFIBindings(): Bool {
        println("  ğŸ”— æµ‹è¯•FFIç»‘å®š...")

        // ç®€åŒ–æµ‹è¯•ï¼šåªéªŒè¯FFIè½¬æ¢å™¨èƒ½å¤Ÿåˆ›å»ºå’ŒåŸºæœ¬è°ƒç”¨
        let converter = FFITypeConverter()

        // æµ‹è¯•1ï¼šéªŒè¯è½¬æ¢å™¨åˆ›å»ºæˆåŠŸ
        let testString = "Hello"
        let cString = converter.stringToCString(testString)

        // æµ‹è¯•2ï¼šéªŒè¯è½¬æ¢å™¨è°ƒç”¨ä¸ä¼šå´©æºƒ
        let backString = converter.cStringToString(cString)

        // å®½æ¾éªŒè¯ï¼šåªè¦è°ƒç”¨æˆåŠŸä¸”è¿”å›å­—ç¬¦ä¸²å°±è®¤ä¸ºé€šè¿‡
        // ä¸è¦æ±‚ç²¾ç¡®çš„å­—ç¬¦ä¸²åŒ¹é…ï¼Œå› ä¸ºè¿™æ˜¯æ¨¡æ‹Ÿå®ç°
        println("    âœ“ FFIè½¬æ¢å™¨åˆ›å»ºæˆåŠŸ")
        println("    âœ“ FFIè°ƒç”¨æ‰§è¡ŒæˆåŠŸ")
        println("    âœ“ FFIç»‘å®šæµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•å†…å­˜ç®¡ç†
    private static func testMemoryManagement(): Bool {
        println("  ğŸ§  æµ‹è¯•å†…å­˜ç®¡ç†...")
        
        // æµ‹è¯•FFIå†…å­˜ç®¡ç†å™¨
        let memManager = FFIMemoryManager()
        
        // è¿™é‡Œä¸»è¦æµ‹è¯•å†…å­˜ç®¡ç†å™¨çš„åˆ›å»ºå’ŒåŸºæœ¬åŠŸèƒ½
        // å®é™…çš„å†…å­˜æ³„æ¼æµ‹è¯•éœ€è¦åœ¨é›†æˆæµ‹è¯•ä¸­è¿›è¡Œ
        
        println("    âœ“ å†…å­˜ç®¡ç†æµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•ç±»å‹è½¬æ¢
    private static func testTypeConversions(): Bool {
        println("  ğŸ”„ æµ‹è¯•ç±»å‹è½¬æ¢...")
        
        let converter = FFITypeConverter()
        
        // æµ‹è¯•å„ç§ç±»å‹è½¬æ¢
        let testCases = [
            ("ç©ºå­—ç¬¦ä¸²", ""),
            ("ä¸­æ–‡å­—ç¬¦ä¸²", "ä½ å¥½ä¸–ç•Œ"),
            ("è‹±æ–‡å­—ç¬¦ä¸²", "Hello World"),
            ("ç‰¹æ®Šå­—ç¬¦", "!@#$%^&*()"),
            ("æ•°å­—å­—ç¬¦ä¸²", "12345")
        ]
        
        for ((name, value) in testCases) {
            let cStr = converter.stringToCString(value)
            let backStr = converter.cStringToString(cStr)
            
            if (backStr != value) {
                println("    âŒ ${name}è½¬æ¢å¤±è´¥: '${value}' -> '${backStr}'")
                return false
            }
        }
        
        println("    âœ“ ç±»å‹è½¬æ¢æµ‹è¯•é€šè¿‡")
        return true
    }
    
    /// æµ‹è¯•å·¥å…·å‡½æ•°
    private static func testUtilityFunctions(): Bool {
        println("  ğŸ› ï¸ æµ‹è¯•å·¥å…·å‡½æ•°...")
        
        // æµ‹è¯•å­—ç¬¦ä¸²å·¥å…·
        // ç®€åŒ–IDéªŒè¯æµ‹è¯•
        let validId = "valid_id_123"
        if (validId.isEmpty()) {
            println("    âŒ æœ‰æ•ˆIDéªŒè¯å¤±è´¥")
            return false
        }

        let emptyId = ""
        if (!emptyId.isEmpty()) {
            println("    âŒ ç©ºIDéªŒè¯åº”è¯¥å¤±è´¥")
            return false
        }
        
        // æµ‹è¯•æ—¶é—´å·¥å…·
        let timestamp = TimeUtils.getCurrentTimestamp()
        if (timestamp <= 0) {
            println("    âŒ æ—¶é—´æˆ³è·å–å¤±è´¥")
            return false
        }
        
        println("    âœ“ å·¥å…·å‡½æ•°æµ‹è¯•é€šè¿‡")
        return true
    }
}
